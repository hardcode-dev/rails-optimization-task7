# ДЗ № 7  

## Оптимизация DX метрик 
 
В рамках данного ДЗ я решил занятся оптимизацией моего рабочего проекта так как у нас есть явные проблемы в прогоне тестов.
 
### Описание текущего сосотояния

Немного информации о текущем состоянии тестов на проекте: 

- Для тестирования мы используем `Rspec`
- Кол-во тест кейсов: `1450`
- Покрытие тестами: `99.68%`
- Время выполнения всех тестов: примерно `11 minutes 26 seconds` (`686 sec`)

### Сбор DX-метрик.  

Для того, что бы следить за прогресом в оптимизации тестов, для начала я решил настроить сбор и визуализацию DX-метрик с помощью `Influxer`.
Для визуализации этих метрик, я решил использовать `Chronograf`, так же как это было описано во время лекции. 

Проведя несколько тестовых и прогнав реальные тесты я получил исходные данные для ткущего состояния: http://joxi.ru/xAeBvzWHgaKwzr

Первый прогон дал результат: `740 sec` ( `12 minutes 20 seconds` )

### Оптимизация  

#### Точка роста №1  

На первом шаге я решил воспользоваться встроенным профилировщиком в `rspec`. 

Результат прогона указал на то, что самые медленные `test-suites` объеденяет одна особенность -- все они связаны с проверкой моделей, которые используют `uploader` для хагрузки изображений. 
В фабриках как я и ожидал(правдивее сказать знал) было указано загружать файл при каждом создании записи.
 
Перед проведением оптимизации я решил глубже изучить инструмент, который я использую для аплоадинга изображений в своем приложении. 
И с удивлением для себя обнаружил, что разработчики позаботились о тех кто использует их труд у себя в проекте и добавили в документацию описание того как можно замокать все внутренние процессы их либы так, что бы не пришлось процессить и грузить файл, а только эмитировать это все. 
К несчастью для меня дока расчитана на свежую версию библиотеки, и не до конца подходила под ту что использую я. Тем не менее изучив предыдущие версии этой доки и взяв только те вещи, которые мне подходят и необходимы, я смог замокать все места которые тормозили мои тесты.  
После внедрения изменений, я еще раз выполнил тесты что бы убедится, что ничего не сломалось. И уже на этом этапе я увидел явное улучшение, так как у меня по дефолту выводится время прогонов тестов в консоли.  

Результат оптимизации оказался намного лучше чем я ожидал: `180 sec` ( `3 minutes 00 seconds` ) 
Даже когда пишу эти цифры, для меня все еще удивительно, что я сократил время прогона тестов в 4(!!!) раза с помощью только одного изменения

Скриншот из `Chronograf`: http://joxi.ru/5mdBvj6HeZM8gA

Прогнав, еще раз тесты с флогом `--profile` я убедился, что точка роста изменилась.

#### Точка роста №2 
 
Дальше я решил воспользоваться `test-prof` и попробовать разные профилировщики, которые можно интегрировать.
Начать я решил с `ruby-prof`. Тут меня ждал неприятный сюрприз: при прогоне больше ~20 семплов выполнение падало с ошибкой `[BUG] Segmentation fault`.  
Я попытался с этим разобраться но ничего не вышло. 
А прогон 10 семплов информации, которая была бы мне полезна не дал(ну или я не смог понять ее). 

Поэтому я решил переключится на `stack-prof`.  
Прогнав часть тестов с профилированием с помощью `stack-prof` и ознакомившись с результатом, я заметил что 2-е топовые позиции 
принадлежат задачам, которые взаимодействуют с БД. Я предположил что скорее всего это из-за частого использования записи/чтения в БД.  

Таким способом я убедился что моя точка роста №2 -- это частое взаимодействие с БД.

Тогда я решил прогнать на нескольких тест кейсах `rspec-dissect` потому, что как я предположил основное взаимодействие с БД, которое есть у меня в тестах -- идет через `let!`.
Проверив свою догадку, я получил подтверждение. Для самой медленной модели я получил вот такой результат: 

````.env
Total time: 00:14.594
Total `let` time: 00:13.654
Total `before(:each)` time: 00:05.115
````

Общее время для этих тест кейсов занял: `Finished in 14.51 seconds (files took 7.14 seconds to load)`

Что бы оптимизировать эту точку роста, я решил воспользоваться хелпером, который предоставляет `test-prof`: `let_it_be` и `before_all`.

После применения этой оптимизции для выбранного мной файла, вот так изменились показатели профилировщика: 

````.env
Total time: 00:00.884

Total `let` time: 00:00.038
Total `before(:each)` time: 00:00.051
````
 
Общее время: `Finished in 5.21 seconds (files took 5.35 seconds to load)`

Таким образом для самого проблемного файла время выполнение было улучшенно почти в 3 раза. 

После этого, я прогнал спеки этого файла с включенным `stack-prof` профайлером и убедился, что то работа с БД перестала быть точкой роста.

### Итога оптимизации 

Когда я приступал к этой задаче, то для себя решил, что в моем случае будет достаточным установить бюджет в `5 min`. 
Так как первый же шаг позволил мне уложится в бюджет, то я решил, что выполню еще одну оптимизацию для практики и лучше усвоения получнных знаний. 
Проанализировав свои тесты я понимаю, что оптимизация всех тест кейсов таким же способом как я это сделал в Шаге 2 даст примерно 2х кратный прирост, что сократит время выполнения всех тестов примерно до `90 sec`.
Этот показатель более чем меня удовлетворит. К сожалению адаптирование всех тест кейсов, займет значительное время. А так как до конца курса осталось мало времени, то я решил сдать работу в этом виде, что бы успеть в срок.
Если я успею пределать все тест кейсы, то я обновлю свои результаты.
